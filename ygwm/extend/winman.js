/*
This file uses a list of window keys to keep keyed windows open in only one instance.
It adds other fancy stuff too, such as patchInnerLinks or hiddenText ...

Dependencies : ygwm.js, storage.js
Use : register_key() is called by all the files that create application windows or documentation,
  so it is included after ygwm and before the menu and the apps.
Note : the window creation function (given to register_key) MUST return the id of the ygwm_div element
  that was just created.
*/

winman={
  base: location.href.split(/\?|#/)[0], // get the page's full address without the hash

  window_keys:[],   // stores either a string (when alias)
  // or a key object (key name, on/off, creator function, ygwm id, key number)

  keys_list:[],  // simple array of the above

  // Add the key and function to the window keys table
  // new version : the whole object is passed, not just the function,
  //  so the key is added to the object
  register_key: function(key,f,m) {
    if (typeof m != "number")
      m=1; // only one window by default
    if ((typeof key != "string") || (typeof f != "function"))
      console.log("Bug\nregister_key : wrong argument type");
    if (winman.window_keys[key]) {
      if (key.substr(0,4) == "ISM/")
        return;  // allow several redefinitions of the same key if we register an ISM key
      else
        console.log('Bug\nkey "'+key+'" already registered');
    };
    winman.window_keys[key]={
      n:key,
      func:f,
      on:false,
      multiple:m,
      nr:winman.keys_list.length
    };
    winman.keys_list.push(key);
  },

////////////////////////////////////////////////////////////////
// This part handles the storage of the window positions, size and visibility
//  "(-)x y w h"    (if x is negative, the window is hidden)

  eraseCallback:function(w) {
    var k=w.key; // w is a window id that we're cleaning up

    localStorage.removeItem(w.lsname);

    k.on=false;
    k.win=null; // prevent memory leak, all links to the window and its contents must be cut
  },

  coord_ondrop:function(w,h){
    if (!h)
      h=1;
    lsPut(w.lsname,
            (w.x * h)
       +" "+ w.y
       +" "+ w.w
       +" "+ w.h );
  },

  coord_onhide:function(w){
    winman.coord_ondrop(w, -1);  // negative number : hidden
  },

  coord_onshow:function(w){
    winman.coord_ondrop(w, 1);   // positive number : visible
  },

////////////////////////////////////////////////////////////////

  activate_window: function(s) { // return : the new window
    var key, t, u, v, v2, w;
    // when called from a A tag, "s" is not a string so we examine the href
    if (typeof s != "string") {
//      t=this.href;
      if (t=this.href){
        u=t.indexOf("#!");
 // u not tested ?
        s = t.slice(u+2); // strip the link of the absolute path
      }
      else return; // invalid parameter type
    }

    // split s into a key and arguments
    u=s.indexOf("#");
    if (u<0) {
      key=s;
      s="";
    } else {
      key=s.slice(0,u);
      s=s.slice(u+1);
    }

    v=key;
    w=winman.window_keys;

    // scan the eventual alias linked list (smart lookup, subtleties inside)
    do{
      if (!w[v]) {
        console.log(I8N("R")+I8N("WrnKey")+"\n"+key);
        return false;
      }
      v2=v;
      v=w[v];
    } while (typeof v=="string");

    if (v.on==false){ // Window not created : create it
      v.win
        = w
        = v.func(v2,key); // Actually, call the object.start(). This way, one object can handle several keys !

      w.key=v;
      var eCb=w.eraseCallback;
      w.eraseCallback=function(w){  // Chain our new callback with the eventual existing one
        eCb&&eCb(w);
        winman.eraseCallback(w);
      };

      if (v.multiple === 1) { // allow multiple windows ?  TODO: replace v.on with a counter (semaphore?)
        v.on=true;
           // When more than one window is possible, v.on is not set to true
           // so the next invocation will create the window again

        if(window.lsGet){ // Is our storage manager loaded ?
          // add this new name to the database
          w.lsname="Win_"+w.key.n;

          // add hooks that preserve the window positions
          w.ondrop=winman.coord_ondrop;
          w.onhide=winman.coord_onhide;
          w.onshow=winman.coord_onshow;
          winman.coord_ondrop(w, 1);
        }
      }
    }
    else { // just display the existing window
      w=v.win;
      ygwm.center_window(w);
      ygwm.focus_window(null,w);
    }

    if(s != "") {
      if (w.trigger)
          w.trigger(s);
      else
        document.location.href="#"+s;
    }
    return w;
  },


//////////////// And now, something totally different...

  autoindex:function(cont, key) {
    // cont: base of the document
    // key : the name to add to the autogenerated links so they don't collide or duplicate
    var i,a="",b,c=0,h,t="Index :<br>",
        d=getByClass("autoindex","DIV",cont);
    if (d) {
      i=cont.firstChild;
      // scan the first level of the DOM tree of the window
      while(i) {
        if ((i.nodeName[0]=="H")
         && (i.nodeName[1]!="1")) {
          if (a==""){
            a=key+"_"+c++;
            b=dcE("A");
            b.name=a;
            cont.insertBefore(b,i);
          }
          for (h=+i.nodeName[1]; h>0; h--)
            t+="&nbsp; ";  // indend proportionally to 
          t+='<a href="#'+a+'">'+i.innerHTML+"</a><br>";
          a="";
        }
        else
          if (i.nodeName=="A")
            a=i.name;  // register the A tag for the next <Hx>
        i=i.nextSibling;
      }
      d.innerHTML=t;
    }
  },

  autoKey:1,

  patchInnerLinks: function(base){
    if (!base)
      return;

    // Scan all the <a> tags
    var i,s,t,
     u=base.getElementsByTagName("a"),
     v;//="";
    for (i in u){
      if(u[i].className=="asm"){
        u[i].href="#!ASM/asm#a?"+u[i].textContent;
        u[i].onclick=winman.activate_window;
        u[i].className="asm_active";
      }
      else {
        if(u[i].className=="disasm"){
          u[i].href="#!ASM/asm#d?"+u[i].textContent;
          u[i].onclick=winman.activate_window;
          u[i].className="disasm_active";
        }
        else {
          if (u[i].className=="opcode"){
            u[i].href="#!ISM/"+u[i].innerHTML;
            u[i].onclick=winman.activate_window;
            u[i].className="opcode_active";
          }
          else {
            if(u[i].href) {
              t=u[i].href;
              // the browser adds the file's full address in front, let's strip it ?
              if ((t.indexOf(winman.base)===0)
               && (t[winman.base.length] == "#")) {
                s=t.indexOf("#!");
                if (s >= 0) {
                  t=t.slice(s+2);
                  s=t.split("#");
                  if(winman.window_keys[s[0]]) {
                    u[i].onclick=winman.activate_window;
                    u[i].className="innerLink";
                    //        v+=s[0];
                  }
                }
              }
              else
                u[i].target="_blank";
            }
          }
        }
      }
    }

    // scan the <pre class="instr">
    u=base.getElementsByTagName("pre");
    for (i in u) {
      t=u[i];
      if (t.className=="instr") {
        s=dcE("DIV");
        s.innerHTML="&nbsp;"+I8N("LstEd")+"&nbsp;";
        s.className="AsmTag";

        v=dcE("DIV");
        v.appendChild(s);
        v.className="AsmVoid";

        t.parentNode.insertBefore(v,t);
        s.onclick=winman.editListing;
      }
    }

    winman.autoindex(base,"_node_"+ winman.autoKey++); // Should be changed
  },

  editListing:function() {
    impASM.importCode(this.parentNode.nextSibling.textContent);
  }
};

// used by the applications to fetch hidden data from the .html
function hiddenText(key,base){
  return getById("hidden"+key,"SPAN",base).innerHTML;
}

for (var i in key_list) {
  var j = key_list[i];
  if (j[1]) winman.register_key(j[0], j[1].start, j[2])
};

wa=winman.activate_window; // HTML ALIAS (resistant to compaction)
